# HA Flask Deployment: Terraform + Ansible Integration (V2)

## ğŸŒŸ Project Overview: Highly Available Infrastructure as Code

This project demonstrates a production-ready **Infrastructure as Code (IaC)** workflow by seamlessly integrating **Terraform** for cloud resource provisioning (Day 0) and **Ansible** for configuration management and application deployment (Day 1).

The goal is to deploy a simple, interactive **Flask Adventure Game** application onto a **Highly Available (HA)** architecture on AWS.

### Architectural Goals

  * **High Availability:** Deploy two identical EC2 instances across two separate **Availability Zones (AZs)** to ensure the application remains functional even if one zone experiences an outage.

  * **Infrastructure Isolation:** Create a dedicated Virtual Private Cloud (VPC) network from scratch, rather than relying on default settings.

  * **Dynamic Handover:** Automatically generate the Ansible host inventory using Terraform's outputs, eliminating manual IP address configuration.

## ğŸ› ï¸ Technology Stack

| Tool | Role | Description |
| :--- | :--- | :--- |
| **Terraform** | **Provisioning (IaC)** | Creates the VPC, Subnets, Internet Gateway, Security Group, and the two EC2 instances. |
| **Ansible** | **Configuration Management** | Connects via SSH to both new EC2s to install Python/Flask, deploy the application code, and start the service. |
| **AWS** | **Cloud Provider** | Hosting environment (EC2, VPC, Networking). |
| **Python/Flask** | **Application** | The simple, state-managing "HA Adventure Game" microservice. |

## ğŸ“ Project Structure

The repository is organized following best practices to separate infrastructure code from configuration code:

```
ha-flask-project/
â”œâ”€â”€ .gitignore               # Ignores .tfstate files, .pem keys, and inventory.ini
â”œâ”€â”€ main.tf                  # Main Terraform configuration (VPC, Subnets, EC2, IGW, SG)
â”œâ”€â”€ ansible/
â”‚   â”œâ”€â”€ inventory.tmpl       # Terraform template to generate the host list
â”‚   â”œâ”€â”€ inventory.ini        # (Generated by Terraform) Ansible's list of live host IPs
â”‚   â”œâ”€â”€ run_deployment.yml   # Master Ansible playbook, which calls the webserver role
â”‚   â””â”€â”€ roles/
â”‚       â””â”€â”€ webserver/
â”‚           â”œâ”€â”€ tasks/
â”‚           â”‚   â””â”€â”€ main.yml # Task logic (Install Python, Copy File, Start App)
â”‚           â””â”€â”€ files/
â”‚               â””â”€â”€ adventure_game.py # The Flask V2 game code

```

## ğŸš€ Deployment Instructions

These instructions assume you are running from a **Linux-like environment (e.g., KodeKloud Terminal)** with Terraform and Ansible installed.

### Prerequisites

1.  **Git, Terraform, and Ansible** installed.

2.  **AWS Key Pair:** A named key pair (e.g., `my-ha-key`) must be imported into your target AWS region, and the matching private key (`~/.ssh/my_ha_key`) must be saved in your local user directory for SSH access.

### Step 1: Initialize Git and Clone (Skip if already on Playground)

*(Assuming files are already in place on the Playground)*

### Step 2: Initialize Terraform

Run this in the root of the project to download the necessary AWS provider:

```
terraform init
```

### Step 3: Provision Infrastructure (Day 0)

Review the plan (which should show about 10 new resources) and apply the changes.

```
terraform plan
terraform apply  # Type 'yes' to confirm
```

***CRUCIAL PAUSE:*** After `terraform apply` finishes, wait **90 seconds** for the two EC2 instances to boot up and initialize SSH.

### Step 4: Configure and Deploy Application (Day 1)

Execute the Ansible playbook, which connects to both EC2 instances simultaneously using the dynamically generated `ansible/inventory.ini` file.

```
ansible-playbook -i ansible/inventory.ini ansible/run_deployment.yml
```

### Step 5: Verification

Use the Public IP addresses output by Terraform (under `server_public_ips`) to access the application on port **8000**:

  * **URL:** `http://<PUBLIC_IP_ADDRESS>:8000`

  * Verify that refreshing the page sometimes shows **different hostnames** in the `Server Hostname:` field, confirming the traffic is being served from two separate, independent machines (the core goal of the HA deployment).

### ğŸ§¹ Cleanup

Always destroy your resources to avoid unnecessary cloud costs:

```
terraform destroy  # Type 'yes' to confirm
```

## ğŸ“ Version History

  * **v2.0.0 (Current):** Upgraded application to an interactive Flask Adventure Game. Implemented Ansible Roles and a robust HA network foundation.

  * **v1.0.0:** Initial basic EC2 deployment and simple "Hello World" configuration.
